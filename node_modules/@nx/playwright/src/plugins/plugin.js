"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNodes = exports.createDependencies = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
const get_named_inputs_1 = require("@nx/devkit/src/utils/get-named-inputs");
const calculate_hash_for_create_nodes_1 = require("@nx/devkit/src/utils/calculate-hash-for-create-nodes");
const workspace_context_1 = require("nx/src/utils/workspace-context");
const minimatch_1 = require("minimatch");
const cache_directory_1 = require("nx/src/utils/cache-directory");
const js_1 = require("@nx/js");
const config_utils_1 = require("@nx/devkit/src/utils/config-utils");
const cachePath = (0, path_1.join)(cache_directory_1.projectGraphCacheDirectory, 'playwright.hash');
const targetsCache = readTargetsCache();
function readTargetsCache() {
    return (0, fs_1.existsSync)(cachePath) ? (0, devkit_1.readJsonFile)(cachePath) : {};
}
function writeTargetsToCache() {
    const oldCache = readTargetsCache();
    (0, devkit_1.writeJsonFile)(cachePath, {
        ...readTargetsCache,
        targetsCache,
    });
}
const createDependencies = () => {
    writeTargetsToCache();
    return [];
};
exports.createDependencies = createDependencies;
exports.createNodes = [
    '**/playwright.config.{js,ts,cjs,cts,mjs,mts}',
    async (configFilePath, options, context) => {
        const projectRoot = (0, path_1.dirname)(configFilePath);
        // Do not create a project if package.json and project.json isn't there.
        const siblingFiles = (0, fs_1.readdirSync)((0, path_1.join)(context.workspaceRoot, projectRoot));
        if (!siblingFiles.includes('package.json') &&
            !siblingFiles.includes('project.json')) {
            return {};
        }
        const normalizedOptions = normalizeOptions(options);
        const hash = (0, calculate_hash_for_create_nodes_1.calculateHashForCreateNodes)(projectRoot, options, context, [
            (0, js_1.getLockFileName)((0, devkit_1.detectPackageManager)(context.workspaceRoot)),
        ]);
        targetsCache[hash] ??= await buildPlaywrightTargets(configFilePath, projectRoot, normalizedOptions, context);
        const { targets, metadata } = targetsCache[hash];
        return {
            projects: {
                [projectRoot]: {
                    root: projectRoot,
                    targets,
                    metadata,
                },
            },
        };
    },
];
async function buildPlaywrightTargets(configFilePath, projectRoot, options, context) {
    // Playwright forbids importing the `@playwright/test` module twice. This would affect running the tests,
    // but we're just reading the config so let's delete the variable they are using to detect this.
    // See: https://github.com/microsoft/playwright/pull/11218/files
    delete process['__pw_initiator__'];
    const playwrightConfig = await (0, config_utils_1.loadConfigFile)((0, path_1.join)(context.workspaceRoot, configFilePath));
    const namedInputs = (0, get_named_inputs_1.getNamedInputs)(projectRoot, context);
    const targets = {};
    let metadata;
    const baseTargetConfig = {
        command: 'playwright test',
        options: {
            cwd: '{projectRoot}',
        },
        metadata: {
            technologies: ['playwright'],
            description: 'Runs Playwright Tests',
        },
    };
    targets[options.targetName] = {
        ...baseTargetConfig,
        cache: true,
        inputs: 'production' in namedInputs
            ? ['default', '^production']
            : ['default', '^default'],
        outputs: getOutputs(projectRoot, playwrightConfig),
    };
    if (options.ciTargetName) {
        const ciBaseTargetConfig = {
            ...baseTargetConfig,
            cache: true,
            inputs: 'production' in namedInputs
                ? ['default', '^production']
                : ['default', '^default'],
            outputs: getOutputs(projectRoot, playwrightConfig),
        };
        const groupName = 'E2E (CI)';
        metadata = { targetGroups: { [groupName]: [] } };
        const ciTargetGroup = metadata.targetGroups[groupName];
        const testDir = playwrightConfig.testDir
            ? (0, devkit_1.joinPathFragments)(projectRoot, playwrightConfig.testDir)
            : projectRoot;
        // Playwright defaults to the following pattern.
        playwrightConfig.testMatch ??= '**/*.@(spec|test).?(c|m)[jt]s?(x)';
        const dependsOn = [];
        forEachTestFile((testFile) => {
            const relativeSpecFilePath = (0, devkit_1.normalizePath)((0, path_1.relative)(projectRoot, testFile));
            const targetName = `${options.ciTargetName}--${relativeSpecFilePath}`;
            ciTargetGroup.push(targetName);
            targets[targetName] = {
                ...ciBaseTargetConfig,
                command: `${baseTargetConfig.command} ${relativeSpecFilePath}`,
                metadata: {
                    technologies: ['playwright'],
                    description: `Runs Playwright Tests in ${relativeSpecFilePath} in CI`,
                },
            };
            dependsOn.push({
                target: targetName,
                projects: 'self',
                params: 'forward',
            });
        }, {
            context,
            path: testDir,
            config: playwrightConfig,
        });
        targets[options.ciTargetName] ??= {};
        targets[options.ciTargetName] = {
            executor: 'nx:noop',
            cache: ciBaseTargetConfig.cache,
            inputs: ciBaseTargetConfig.inputs,
            outputs: ciBaseTargetConfig.outputs,
            dependsOn,
            metadata: {
                technologies: ['playwright'],
                description: 'Runs Playwright Tests in CI',
            },
        };
        ciTargetGroup.push(options.ciTargetName);
    }
    return { targets, metadata };
}
function forEachTestFile(cb, opts) {
    const files = (0, workspace_context_1.getFilesInDirectoryUsingContext)(opts.context.workspaceRoot, opts.path);
    const matcher = createMatcher(opts.config.testMatch);
    const ignoredMatcher = opts.config.testIgnore
        ? createMatcher(opts.config.testIgnore)
        : () => false;
    for (const file of files) {
        if (matcher(file) && !ignoredMatcher(file)) {
            cb(file);
        }
    }
}
function createMatcher(pattern) {
    if (Array.isArray(pattern)) {
        const matchers = pattern.map((p) => createMatcher(p));
        return (path) => matchers.some((m) => m(path));
    }
    else if (pattern instanceof RegExp) {
        return (path) => pattern.test(path);
    }
    else {
        return (path) => {
            try {
                return (0, minimatch_1.minimatch)(path, pattern);
            }
            catch (e) {
                throw new Error(`Error matching ${path} with ${pattern}: ${e.message}`);
            }
        };
    }
}
function getOutputs(projectRoot, playwrightConfig) {
    function getOutput(path) {
        if (path.startsWith('..')) {
            return (0, path_1.join)('{workspaceRoot}', (0, path_1.join)(projectRoot, path));
        }
        else {
            return (0, path_1.join)('{projectRoot}', path);
        }
    }
    const outputs = [];
    const { reporter, outputDir } = playwrightConfig;
    if (reporter) {
        const DEFAULT_REPORTER_OUTPUT = getOutput('playwright-report');
        if (reporter === 'html' || reporter === 'json') {
            // Reporter is a string, so it uses the default output directory.
            outputs.push(DEFAULT_REPORTER_OUTPUT);
        }
        else if (Array.isArray(reporter)) {
            for (const r of reporter) {
                const [, opts] = r;
                // There are a few different ways to specify an output file or directory
                // depending on the reporter. This is a best effort to find the output.
                if (!opts) {
                    outputs.push(DEFAULT_REPORTER_OUTPUT);
                }
                else if (opts.outputFile) {
                    outputs.push(getOutput(opts.outputFile));
                }
                else if (opts.outputDir) {
                    outputs.push(getOutput(opts.outputDir));
                }
                else if (opts.outputFolder) {
                    outputs.push(getOutput(opts.outputFolder));
                }
                else {
                    outputs.push(DEFAULT_REPORTER_OUTPUT);
                }
            }
        }
    }
    if (outputDir) {
        outputs.push(getOutput(outputDir));
    }
    else {
        outputs.push(getOutput('./test-results'));
    }
    return outputs;
}
function normalizeOptions(options) {
    return {
        ...options,
        targetName: options.targetName ?? 'e2e',
        ciTargetName: options.ciTargetName ?? 'e2e-ci',
    };
}
