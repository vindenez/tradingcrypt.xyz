"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storiesGenerator = exports.createAllStories = void 0;
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const versions_1 = require("../../utils/versions");
const component_story_1 = require("./lib/component-story");
const minimatch_1 = require("minimatch");
async function createAllStories(tree, projectName, interactionTests, js, projectConfiguration, ignorePaths) {
    const { sourceRoot } = projectConfiguration;
    let componentPaths = [];
    const pathsToCheck = [
        (0, devkit_1.joinPathFragments)(sourceRoot, 'app'), // Default component folder for apps
        (0, devkit_1.joinPathFragments)(sourceRoot, 'lib'), // Default component folder for libs
        (0, devkit_1.joinPathFragments)(sourceRoot, 'components'), // Additional component folder used by Nuxt
    ];
    for (const p of pathsToCheck) {
        (0, devkit_1.visitNotIgnoredFiles)(tree, p, (path) => {
            // Ignore private files starting with "_".
            if ((0, path_1.basename)(path).startsWith('_'))
                return;
            if (ignorePaths?.some((pattern) => (0, minimatch_1.minimatch)(path, pattern)))
                return;
            if (path.endsWith('.vue')) {
                // Let's see if the .stories.* file exists
                const ext = path.slice(path.lastIndexOf('.'));
                const storyPathJs = `${path.split(ext)[0]}.stories.js`;
                const storyPathTs = `${path.split(ext)[0]}.stories.ts`;
                if (!tree.exists(storyPathJs) && !tree.exists(storyPathTs)) {
                    componentPaths.push(path);
                }
            }
        });
    }
    await Promise.all(componentPaths.map(async (componentPath) => {
        const relativeCmpDir = componentPath.replace((0, path_1.join)(sourceRoot, '/'), '');
        (0, component_story_1.createComponentStories)(tree, {
            project: projectName,
            interactionTests,
            js,
        }, relativeCmpDir);
    }));
}
exports.createAllStories = createAllStories;
async function storiesGenerator(host, schema) {
    const projects = (0, devkit_1.getProjects)(host);
    const projectConfiguration = projects.get(schema.project);
    schema.interactionTests = schema.interactionTests ?? true;
    await createAllStories(host, schema.project, schema.interactionTests, schema.js, projectConfiguration, schema.ignorePaths);
    const tasks = [];
    if (schema.interactionTests) {
        const { interactionTestsDependencies, addInteractionsInAddons } = (0, devkit_1.ensurePackage)('@nx/storybook', versions_1.nxVersion);
        tasks.push((0, devkit_1.addDependenciesToPackageJson)(host, {}, interactionTestsDependencies()));
        addInteractionsInAddons(host, projectConfiguration);
    }
    if (!schema.skipFormat) {
        await (0, devkit_1.formatFiles)(host);
    }
    return (0, devkit_1.runTasksInSerial)(...tasks);
}
exports.storiesGenerator = storiesGenerator;
exports.default = storiesGenerator;
